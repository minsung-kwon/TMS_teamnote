GED (Generalized Edit Distance)는 일반적으로 두 문자열 사이의 차이를 측정하는 알고리즘입니다. C++에서 GED를 구현하려면 두 문자열 간의 최소 편집 거리를 계산하는 알고리즘을 작성해야 합니다. 대표적인 방법으로 Levenshtein Distance(편집 거리) 알고리즘을 사용할 수 있습니다. 이는 두 문자열을 일치시키기 위해 삽입, 삭제, 교체해야 하는 최소 편집 작업 수를 계산합니다.

Levenshtein Distance 구현 예시
```cpp
#include <iostream>
#include <vector>
#include <string>
#include <algorithm>

int LevenshteinDistance(const std::string& str1, const std::string& str2) {
    int len1 = str1.size();
    int len2 = str2.size();
    
    // 2차원 벡터를 사용해 동적 계획법(DP) 테이블을 만듦
    std::vector<std::vector<int>> dp(len1 + 1, std::vector<int>(len2 + 1));

    // 첫 번째 문자열이 빈 문자열로 변환되는 경우
    for (int i = 0; i <= len1; ++i) {
        dp[i][0] = i;
    }

    // 두 번째 문자열이 빈 문자열로 변환되는 경우
    for (int j = 0; j <= len2; ++j) {
        dp[0][j] = j;
    }

    // DP를 사용하여 최소 편집 거리를 계산
    for (int i = 1; i <= len1; ++i) {
        for (int j = 1; j <= len2; ++j) {
            if (str1[i - 1] == str2[j - 1]) {
                dp[i][j] = dp[i - 1][j - 1];  // 문자가 같으면 편집 필요 없음
            } else {
                dp[i][j] = std::min({dp[i - 1][j] + 1,   // 삭제
                                     dp[i][j - 1] + 1,   // 삽입
                                     dp[i - 1][j - 1] + 1}); // 교체
            }
        }
    }

    // dp[len1][len2]에는 최소 편집 거리가 저장됨
    return dp[len1][len2];
}

int main() {
    std::string str1 = "kitten";
    std::string str2 = "sitting";

    std::cout << "Levenshtein Distance: " << LevenshteinDistance(str1, str2) << std::endl;

    return 0;
}
```
코드 설명:
입력: 두 문자열 str1과 str2가 주어집니다.
동적 계획법 테이블 초기화: 두 문자열의 길이를 기준으로 DP 테이블을 초기화합니다. 이 테이블은 각 부분 문자열 간의 편집 거리를 저장합니다.
기본 규칙:
문자가 같으면 그 이전의 편집 거리를 그대로 가져옵니다.
문자가 다르면 삽입, 삭제, 교체 중 최소 작업을 선택합니다.
최종 결과: DP 테이블의 마지막 값이 두 문자열 간의 최소 편집 거리를 나타냅니다.
예시 실행:
kitten과 sitting의 편집 거리는 3입니다. kitten -> sitten -> sittin -> sitting으로 교체 1회, 삽입 2회가 필요합니다.
